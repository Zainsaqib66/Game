<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Tic Tac Toe</title>
    <style>
        /* Google Font */
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap');

        :root {
            /* Default Colors */
            --cell-bg: rgba(255, 255, 255, 0.9);
            --cell-hover-bg: rgba(255, 255, 255, 0.7);
            --cell-active-bg: rgba(255, 255, 255, 0.5);
            --text-color: #333333;
            --button-bg: #ff7e5f;
            --button-hover-bg: #feb47b;
            --shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            --highlight-color: #4CAF50;
            --status-color: #333;
            --container-bg: rgba(255, 255, 255, 0.95);
            --border-color: #ccc;
            --dark-container-bg: rgba(50, 50, 50, 0.95);
            --dark-text-color: #f0f0f0;
            --dark-button-bg: #2980b9;
            --dark-button-hover-bg: #3498db;
            --dark-border-color: #2980b9;
            --dark-primary-gradient: linear-gradient(135deg, #2c3e50 0%, #4ca1af 100%);
        }

        /* Existing Themes */
        .theme-default {
            --primary-gradient: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            --border-color: #f093fb;
            --button-bg: #f093fb;
            --button-hover-bg: #f5576c;
            --cell-hover-bg: rgba(255, 228, 213, 0.7);
            --cell-active-bg: rgba(255, 209, 179, 0.5);
        }

        .theme-ocean {
            --primary-gradient: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
            --border-color: #43e97b;
            --button-bg: #43e97b;
            --button-hover-bg: #38f9d7;
            --cell-hover-bg: rgba(217, 255, 229, 0.7);
            --cell-active-bg: rgba(179, 255, 209, 0.5);
        }

        .theme-sunset {
            --primary-gradient: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            --border-color: #fa709a;
            --button-bg: #fa709a;
            --button-hover-bg: #fee140;
            --cell-hover-bg: rgba(255, 229, 240, 0.7);
            --cell-active-bg: rgba(255, 209, 230, 0.5);
        }

        .theme-forest {
            --primary-gradient: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            --border-color: #11998e;
            --button-bg: #11998e;
            --button-hover-bg: #38ef7d;
            --cell-hover-bg: rgba(217, 255, 229, 0.7);
            --cell-active-bg: rgba(179, 255, 209, 0.5);
        }

        /* New Themes Added Below */
        .theme-sky {
            --primary-gradient: linear-gradient(135deg, #89f7fe 0%, #66a6ff 100%);
            --border-color: #89f7fe;
            --button-bg: #89f7fe;
            --button-hover-bg: #66a6ff;
            --cell-hover-bg: rgba(136, 247, 254, 0.7);
            --cell-active-bg: rgba(102, 166, 255, 0.5);
        }

        .theme-lavender {
            --primary-gradient: linear-gradient(135deg, #c3cfe2 0%, #c3cfe2 100%);
            --border-color: #c3cfe2;
            --button-bg: #c3cfe2;
            --button-hover-bg: #a3b1c6;
            --cell-hover-bg: rgba(195, 207, 226, 0.7);
            --cell-active-bg: rgba(163, 177, 198, 0.5);
        }

        .theme-peach {
            --primary-gradient: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
            --border-color: #ffecd2;
            --button-bg: #ffecd2;
            --button-hover-bg: #fcb69f;
            --cell-hover-bg: rgba(255, 236, 210, 0.7);
            --cell-active-bg: rgba(252, 182, 159, 0.5);
        }

        .theme-mint {
            --primary-gradient: linear-gradient(135deg, #a1ffce 0%, #faffd1 100%);
            --border-color: #a1ffce;
            --button-bg: #a1ffce;
            --button-hover-bg: #faffd1;
            --cell-hover-bg: rgba(161, 255, 206, 0.7);
            --cell-active-bg: rgba(250, 255, 209, 0.5);
        }

        /* Dark Mode Styles */
        .dark-mode {
            --primary-gradient: var(--dark-primary-gradient);
            --container-bg: var(--dark-container-bg);
            --text-color: var(--dark-text-color);
            --button-bg: var(--dark-button-bg);
            --button-hover-bg: var(--dark-button-hover-bg);
            --border-color: var(--dark-border-color);
            --status-color: var(--dark-text-color);
            /* Overriding additional variables for dark mode */
            --cell-bg: rgba(70, 70, 70, 0.9);
            --cell-hover-bg: rgba(100, 100, 100, 0.7);
            --cell-active-bg: rgba(130, 130, 130, 0.5);
        }

        /* Adjustments for Each Theme in Dark Mode */
        .dark-mode.theme-default {
            --cell-bg: rgba(70, 70, 70, 0.9);
            --cell-hover-bg: rgba(100, 100, 100, 0.7);
            --cell-active-bg: rgba(130, 130, 130, 0.5);
        }

        .dark-mode.theme-ocean {
            --cell-bg: rgba(60, 80, 100, 0.9);
            --cell-hover-bg: rgba(80, 100, 120, 0.7);
            --cell-active-bg: rgba(100, 120, 140, 0.5);
        }

        .dark-mode.theme-sunset {
            --cell-bg: rgba(120, 80, 60, 0.9);
            --cell-hover-bg: rgba(140, 100, 80, 0.7);
            --cell-active-bg: rgba(160, 120, 100, 0.5);
        }

        .dark-mode.theme-forest {
            --cell-bg: rgba(60, 100, 60, 0.9);
            --cell-hover-bg: rgba(80, 120, 80, 0.7);
            --cell-active-bg: rgba(100, 140, 100, 0.5);
        }

        .dark-mode.theme-night {
            --cell-bg: rgba(30, 30, 30, 0.9);
            --cell-hover-bg: rgba(50, 50, 50, 0.7);
            --cell-active-bg: rgba(70, 70, 70, 0.5);
        }

        .dark-mode.theme-spring {
            --cell-bg: rgba(80, 100, 80, 0.9);
            --cell-hover-bg: rgba(100, 120, 100, 0.7);
            --cell-active-bg: rgba(120, 140, 120, 0.5);
        }

        .dark-mode.theme-sky {
            --cell-bg: rgba(70, 90, 110, 0.9);
            --cell-hover-bg: rgba(90, 110, 130, 0.7);
            --cell-active-bg: rgba(110, 130, 150, 0.5);
        }

        .dark-mode.theme-lavender {
            --cell-bg: rgba(80, 80, 100, 0.9);
            --cell-hover-bg: rgba(100, 100, 120, 0.7);
            --cell-active-bg: rgba(120, 120, 140, 0.5);
        }

        .dark-mode.theme-peach {
            --cell-bg: rgba(100, 80, 60, 0.9);
            --cell-hover-bg: rgba(120, 100, 80, 0.7);
            --cell-active-bg: rgba(140, 120, 100, 0.5);
        }

        .dark-mode.theme-mint {
            --cell-bg: rgba(80, 100, 80, 0.9);
            --cell-hover-bg: rgba(100, 120, 100, 0.7);
            --cell-active-bg: rgba(120, 140, 120, 0.5);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: var(--primary-gradient);
            font-family: 'Poppins', sans-serif;
            transition: background 0.5s ease-in-out;
        }

        /* Loading Screen Styles */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--container-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000; /* Above all other elements */
        }

        /* Loader Animation */
        .loader {
            display: flex;
            gap: 15px;
        }

        .loader div {
            width: 20px;
            height: 20px;
            background-color: var(--button-bg);
            border-radius: 50%;
            animation: bounce 1s infinite;
        }

        .loader div:nth-child(2) {
            animation-delay: 0.2s;
        }

        .loader div:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes bounce {
            0%, 80%, 100% {
                transform: scale(0);
            }
            40% {
                transform: scale(1);
            }
        }

        /* Fade Out Animation for Loading Screen */
        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; visibility: hidden; }
        }

        .loading-screen.fade-out {
            animation: fadeOut 1s forwards;
        }

        .container {
            text-align: center;
            background: var(--container-bg);
            padding: 20px 25px;
            border-radius: 30px;
            box-shadow: var(--shadow);
            max-width: 700px;
            width: 95vw;
            transition: all 0.3s ease-in-out;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative; /* For positioning notification modals */
        }

        /* Button Styles */
        .button {
            padding: 12px 25px;
            font-size: 1em;
            cursor: pointer;
            background: var(--button-bg);
            color: #fff;
            border: none;
            border-radius: 30px;
            transition: background-color 0.3s, transform 0.2s;
            box-shadow: var(--shadow);
            margin: 10px;
        }

        .button:hover {
            background: var(--button-hover-bg);
            transform: translateY(-2px);
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }

        .menu-buttons .button {
            width: 80%;
            margin-bottom: 15px;
        }

        #game-board-container {
            width: 100%;
            max-width: 600px; /* Increased max-width for larger cells */
            margin: 0 auto;
        }

        .game-board {
            display: grid;
            gap: 5px; /* Adjusted for better spacing */
            padding: 5px; /* Adjusted for better spacing */
            background: var(--cell-bg);
            border: 4px solid var(--border-color);
            border-radius: 20px;
            transition: transform 0.3s;
            margin-top: 20px;
        }

        .game-board div {
            display: flex;
            justify-content: center;
            align-items: center;
            background: var(--cell-bg);
            border: 1px solid var(--border-color);
            font-size: 1.5em; /* Increased font size for larger cells */
            font-weight: 600;
            cursor: pointer;
            user-select: none;
            border-radius: 15px; /* Increased border-radius */
            transition: background-color 0.3s, transform 0.2s, box-shadow 0.3s;
            position: relative;
            overflow: hidden;
            width: 100%; /* Ensure cells fill the grid */
            aspect-ratio: 1 / 1; /* Make cells square */
            color: var(--text-color);
        }

        .game-board div.hidden {
            background: var(--cell-bg);
            color: transparent;
        }

        .game-board div:hover {
            background: var(--cell-hover-bg);
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .game-board div.disabled {
            cursor: not-allowed;
            background: var(--cell-active-bg);
            color: var(--text-color);
            box-shadow: inset 0 0 5px rgba(0,0,0,0.2);
        }

        /* Custom Select Styles */
        .custom-select {
            position: relative;
            font-family: 'Poppins', sans-serif;
            width: 80%;
            margin-bottom: 20px;
        }

        .select-selected {
            background-color: #ffffff;
            padding: 12px;
            border-radius: 30px;
            cursor: pointer;
            user-select: none;
            box-shadow: var(--shadow);
            position: relative;
            font-weight: 600;
            color: var(--text-color);
        }

        .select-selected:after {
            content: "";
            position: absolute;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            border: 6px solid transparent;
            border-color: #ccc transparent transparent transparent;
        }

        .select-selected.select-arrow-active:after {
            border-color: transparent transparent #ccc transparent;
            top: 55%;
        }

        .select-items {
            position: absolute;
            background-color: #ffffff;
            top: 100%;
            left: 0;
            right: 0;
            z-index: 99;
            border-radius: 30px;
            box-shadow: var(--shadow);
            overflow: hidden;
            max-height: 200px;
            overflow-y: auto;
        }

        .select-hide {
            display: none;
        }

        .select-items div {
            padding: 12px;
            cursor: pointer;
            font-weight: 600;
            color: var(--text-color);
        }

        .select-items div:hover {
            background-color: var(--cell-hover-bg);
        }

        .same-as-selected {
            background-color: var(--cell-active-bg);
        }

        /* Status and Scoreboard */
        .status {
            margin-top: 15px;
            font-size: 1.2em;
            font-weight: 600;
            color: var(--status-color);
            min-height: 1.2em;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }

        .scoreboard {
            margin-top: 15px;
            font-size: 1.2em;
            color: var(--text-color);
            display: flex;
            justify-content: space-around;
        }

        /* Top Buttons */
        .top-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .top-buttons .button {
            padding: 10px 20px;
            font-size: 0.9em;
            margin: 0;
        }

        /* Hidden Elements */
        .hidden-element {
            display: none;
        }

        /* Player Names */
        .player-names {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
            flex-wrap: wrap;
            width: 100%;
        }

        .player-names input {
            padding: 10px 15px;
            border: 2px solid var(--border-color);
            border-radius: 30px;
            font-size: 1em;
            width: 45%;
            margin-bottom: 15px;
            transition: border-color 0.3s;
            background: #f9f9f9;
            color: var(--text-color);
        }

        .player-names input:focus {
            border-color: var(--button-bg);
            outline: none;
        }

        /* Sound Toggle - Removed from Main Menu */

        /* Dark Mode Toggle - Removed from Main Menu */

        /* Dark Mode Toggle */
        .dark-mode-toggle {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 15px;
        }

        .dark-mode-toggle label {
            margin-left: 8px;
            font-size: 1em;
            color: var(--text-color);
            user-select: none;
        }

        /* Settings Modal */
        .settings-modal {
            display: none;
            position: fixed;
            z-index: 1001;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .settings-content {
            background-color: var(--container-bg);
            margin: auto;
            padding: 20px;
            border: 2px solid var(--border-color);
            width: 80%;
            max-width: 500px;
            border-radius: 30px;
            box-shadow: var(--shadow);
            position: relative;
            animation: fadeInModal 0.5s ease;
        }

        @keyframes fadeInModal {
            from { opacity: 0; transform: translateY(-50px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Confetti Canvas */
        #confetti-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }

        /* Responsive Design */
        @media (max-width: 600px) {
            .container {
                width: 95vw;
                padding: 15px 20px;
            }

            .game-board div {
                font-size: 1.2em; /* Slightly smaller font on small screens */
            }

            .status {
                font-size: 1em;
            }

            .button {
                padding: 8px 16px;
                font-size: 0.9em;
            }

            .top-buttons .button {
                padding: 6px 12px;
                font-size: 0.8em;
            }

            .player-names input {
                width: 100%;
            }
        }

        /* Winning Animation */
        .highlight {
            animation: highlight 1s ease-in-out infinite alternate;
        }

        @keyframes highlight {
            from { background: var(--cell-active-bg); }
            to { background: var(--button-hover-bg); }
        }

        /* Win Animation */
        .win-animation {
            animation: winScale 0.5s ease-in-out;
        }

        @keyframes winScale {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        /* Custom Modal Styles */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1002; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: rgba(0,0,0,0.5); /* Black w/ opacity */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal .modal-content {
            background-color: var(--container-bg);
            padding: 20px;
            border: 2px solid var(--border-color);
            width: 80%;
            max-width: 400px;
            border-radius: 30px;
            box-shadow: var(--shadow);
            position: relative;
            text-align: center;
            animation: fadeInModal 0.5s ease;
        }

        .modal .close-notification {
            color: var(--text-color);
            position: absolute;
            top: 10px;
            right: 20px;
            font-size: 1.5rem;
            cursor: pointer;
            transition: color 0.3s;
        }

        .modal .close-notification:hover,
        .modal .close-notification:focus {
            color: var(--button-hover-bg);
            text-decoration: none;
            cursor: pointer;
        }

        /* Enhanced Notification Modal */
        #notification-modal .modal-content {
            background-color: var(--container-bg);
            padding: 30px 20px;
            border: 2px solid var(--border-color);
            width: 90%;
            max-width: 450px;
            border-radius: 30px;
            box-shadow: var(--shadow);
            position: relative;
            text-align: center;
            animation: slideIn 0.6s ease-out;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #notification-modal .modal-content p {
            font-size: 1.2em;
            margin-top: 20px;
            color: var(--text-color);
            animation: fadeInText 1s ease-in;
        }

        /* New Animations for Notification */
        @keyframes slideIn {
            from { opacity: 0; transform: translateY(-100px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes fadeInText {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Optional: Add an Icon to Notification */
        #notification-modal .modal-content::before {
            content: "ðŸŽ‰";
            font-size: 3em;
            margin-bottom: 10px;
            animation: pop 0.5s ease-out;
        }

        @keyframes pop {
            from { transform: scale(0.5); }
            to { transform: scale(1); }
        }

        /* O Styles */
        .O-red {
            color: red;
        }

        .O-blue {
            color: blue;
        }

        .O-green {
            color: green;
        }

        .O-purple {
            color: purple;
        }

        .O-orange {
            color: orange;
        }

        .O-pink {
            color: pink;
        }

        /* X Styles per Theme */
        .theme-default .X {
            color: #f093fb;
        }

        .theme-ocean .X {
            color: #38f9d7;
        }

        .theme-sunset .X {
            color: #fee140;
        }

        .theme-forest .X {
            color: #38ef7d;
        }

        .theme-night .X {
            color: #004e92;
        }

        .theme-spring .X {
            color: #c2e9fb;
        }

        /* New Themes X Styles */
        .theme-sky .X {
            color: #66a6ff;
        }

        .theme-lavender .X {
            color: #a1c4fd;
        }

        .theme-peach .X {
            color: #fcb69f;
        }

        .theme-mint .X {
            color: #a1ffce;
        }
    </style>
</head>
<body>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3414123640565149"
     crossorigin="anonymous"></script>
<!-- adss -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3414123640565149"
     data-ad-slot="9137026598"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
    <!-- Loading Screen -->
    <div id="loading-screen" class="loading-screen">
        <div class="loader">
            <div></div>
            <div></div>
            <div></div>
        </div>
    </div>

    <div class="container" id="game-container" style="display: none;"> <!-- Initially hidden -->
        <!-- Initial Menu -->
        <div id="initial-menu">
            <div class="menu-buttons">
                <button class="button" onclick="startGame('player')">2 Players</button>
                <button class="button" onclick="startGame('computer')">Play vs Computer</button>
                <div class="custom-select" id="board-size-select">
                    <div class="select-selected" data-value="4">Select Grid Size (4x4)</div>
                    <div class="select-items select-hide">
                        <div data-value="4">4x4</div>
                        <div data-value="5">5x5</div>
                        <div data-value="6">6x6</div>
                        <div data-value="7">7x7</div>
                        <div data-value="8">8x8</div>
                    </div>
                </div>
                <!-- AI Difficulty Level -->
                <div class="custom-select" id="ai-difficulty-select" style="display: none;">
                    <div class="select-selected" data-value="medium">Select AI Difficulty (Medium)</div>
                    <div class="select-items select-hide">
                        <div data-value="easy">Easy</div>
                        <div data-value="medium">Medium</div>
                        <div data-value="hard">Hard</div>
                    </div>
                </div>
                <!-- Theme Selection -->
                <div class="custom-select" id="theme-select">
                    <div class="select-selected" data-value="theme-default">Select Theme (Default)</div>
                    <div class="select-items select-hide">
                        <div data-value="theme-default">Default</div>
                        <div data-value="theme-ocean">Ocean</div>
                        <div data-value="theme-sunset">Sunset</div>
                        <div data-value="theme-forest">Forest</div>

                        <!-- New Themes Added Below -->
                        <div data-value="theme-sky">Sky</div>
                        <div data-value="theme-lavender">Lavender</div>
                        <div data-value="theme-peach">Peach</div>
                        <div data-value="theme-mint">Mint</div>
                    </div>
                </div>
            </div>
            <!-- Player Names -->
            <div class="player-names">
                <input type="text" id="playerX-name" placeholder="Player X Name" maxlength="12">
                <input type="text" id="playerO-name" placeholder="Player O Name" maxlength="12">
            </div>
            <!-- Settings Button -->
            <button class="button" onclick="openSettings()">Settings</button>
        </div>

        <!-- Game Interface -->
        <div id="game-interface" class="hidden-element">
            <div class="top-buttons">
                <!-- Hint and Undo buttons will be dynamically shown based on mode -->
                <button class="button hidden-element" id="hint-button" onclick="showHint()">Hint</button>
                <button class="button hidden-element" id="undo-button" onclick="undoMove()">Undo Move</button>
                <button class="button" id="exit-button" onclick="exitGame()">Exit</button>
            </div>
            <div id="game-board-container">
                <div id="game-board" class="game-board"></div>
            </div>
            <div id="status" class="status">Player X's turn</div>
            <div class="scoreboard" id="scoreboard">
                <div id="playerX-score">Player X: 0</div>
                <div id="playerO-score">Player O: 0</div>
            </div>
            <!-- Achievements - Removed -->
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="settings-modal modal">
        <div class="modal-content settings-content">
            <span class="close-notification" onclick="closeSettings(event)">&times;</span>
            <h2>Settings</h2>
            <!-- Settings Options -->
            <div class="sound-toggle">
                <input type="checkbox" id="settings-sound-toggle" checked>
                <label for="settings-sound-toggle">Enable Sound</label>
            </div>
            <div class="dark-mode-toggle">
                <input type="checkbox" id="settings-dark-mode-toggle">
                <label for="settings-dark-mode-toggle">Enable Dark Mode</label>
            </div>
            <!-- Additional Settings can be added here -->
        </div>
    </div>

    <!-- Notification Modal -->
    <div id="notification-modal" class="modal">
        <div class="modal-content">
            <span class="close-notification" onclick="closeNotification(event)">&times;</span>
            <p id="notification-message"></p>
        </div>
    </div>

    <!-- Confetti Canvas -->
    <canvas id="confetti-canvas"></canvas>

    <!-- Sound Effects -->
    <audio id="move-sound" src="https://www.soundjay.com/buttons/sounds/button-16.mp3"></audio>
    <audio id="win-sound" src="https://www.soundjay.com/misc/sounds/bell-ringing-05.mp3"></audio>
    <audio id="draw-sound" src="https://www.soundjay.com/buttons/sounds/button-10.mp3"></audio>
    <audio id="click-sound" src="https://www.soundjay.com/buttons/sounds/button-09.mp3"></audio>

    <!-- Confetti Library -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>

    <!-- JavaScript Code -->
    <script>
   <!-- JavaScript Code -->

    // Game State Variables
    let currentPlayer = 'X';
    let gameActive = true;
    let board = [];
    let gridSize = 4;
    let winCondition = 4; // Updated default win condition
    let moveHistory = [];
    let scores = { 'X': 0, 'O': 0 };
    let mode = 'player'; // 'player' or 'computer'
    let hintUsed = false;
    let undoUsed = false;
    let soundEnabled = true;
    let aiDifficulty = 'medium';
    let selectedTheme = 'theme-default';

    // Statistics
    let statistics = {
        totalGames: 0,
        totalWins: 0,
        totalLosses: 0,
        totalDraws: 0
    };

    // Player Names
    let playerXName = 'Player X';
    let playerOName = 'Player O';

    // Theme Array
    const themes = [
        'theme-default',
        'theme-ocean',
        'theme-sunset',
        'theme-forest',
        'theme-night',
        'theme-spring',
        'theme-sky',       // New Theme 1
        'theme-lavender',  // New Theme 2
        'theme-peach',     // New Theme 3
        'theme-mint'       // New Theme 4
    ];

    // O Styles Array
    const oStyles = ['O-red', 'O-blue', 'O-green', 'O-purple', 'O-orange', 'O-pink'];

    // Initialize Custom Select Dropdown and Other Features
    document.addEventListener('DOMContentLoaded', () => {
        const loadingScreen = document.getElementById('loading-screen');
        const gameContainer = document.getElementById('game-container');

        // Show the loading screen on initial load
        loadingScreen.style.display = 'flex';
        gameContainer.style.display = 'none'; // Hide the game interface initially

        // After 4.5 seconds, hide the loading screen and show notifications
        setTimeout(() => {
            // Add fade-out animation
            loadingScreen.classList.add('fade-out');

            // After fade-out animation ends, hide the loading screen
            loadingScreen.addEventListener('animationend', async () => {
                loadingScreen.style.display = 'none';

                // Proceed with existing initialization
                initializeCustomSelect();
                initializeSoundToggle();
                initializeDarkMode();
                loadPlayerNames();
                loadScores();
                loadSettings();
                loadStatistics();
                applySelectedTheme();
                window.addEventListener('resize', adjustCellSizes); // Adjust cells on window resize

                // Show the notifications and then show the game container
                await checkIfGameOpened();
            });

        }, 4500); // 4.5 seconds
    });

    // Function to check if the game has been opened before and show notifications
    async function checkIfGameOpened() {
        if (!localStorage.getItem('gameOpened')) {
     // First time opening the game
localStorage.setItem('gameOpened', 'true');
await showNotification('Welcome to Tic Tac Toe!');
} else {
    // Game has been opened before
    await showNotification('Welcome back to Tic Tac Toe!');
}

document.getElementById('game-container').style.display = 'flex'; // Show the game interface after notifications
}


    // Initialize Custom Select Dropdown
    function initializeCustomSelect() {
        const selects = document.querySelectorAll('.custom-select');
        selects.forEach(select => {
            const selected = select.querySelector('.select-selected');
            const optionsContainer = select.querySelector('.select-items');
            const optionsList = optionsContainer.querySelectorAll('div');

            selected.addEventListener('click', (e) => {
                e.stopPropagation();
                closeAllSelect(selected);
                optionsContainer.classList.toggle('select-hide');
                selected.classList.toggle('select-arrow-active');
                playSound('click');
            });

            optionsList.forEach(option => {
                option.addEventListener('click', () => {
                    selected.innerHTML = `${option.innerHTML}`;
                    selected.setAttribute('data-value', option.getAttribute('data-value'));

                    // Remove 'same-as-selected' class from all options
                    optionsList.forEach(opt => opt.classList.remove('same-as-selected'));
                    // Add 'same-as-selected' class to selected option
                    option.classList.add('same-as-selected');

                    optionsContainer.classList.add('select-hide');
                    selected.classList.remove('select-arrow-active');

                    // Handle selection changes
                    if (select.id === 'board-size-select') {
                        // If game is already active, restart the game with new grid size
                        if (!document.getElementById('game-interface').classList.contains('hidden-element')) {
                            setupGame();
                        }
                    } else if (select.id === 'ai-difficulty-select') {
                        aiDifficulty = selected.getAttribute('data-value');
                        saveSettings();
                    } else if (select.id === 'theme-select') {
                        selectedTheme = selected.getAttribute('data-value');
                        applySelectedTheme();
                        saveSettings();
                    }

                    playSound('click');
                });
            });
        });

        // Close all select boxes if clicked outside
        document.addEventListener('click', closeAllSelect);
    }

    function closeAllSelect(element) {
        const selected = document.querySelectorAll('.select-selected');
        const optionsContainers = document.querySelectorAll('.select-items');

        selected.forEach(sel => {
            if (sel !== element) {
                sel.classList.remove('select-arrow-active');
            }
        });

        optionsContainers.forEach(container => {
            if (!container.contains(element)) {
                container.classList.add('select-hide');
            }
        });
    }

    // Initialize Sound Toggle (Only Settings Modal)
    function initializeSoundToggle() {
        const settingsSoundToggle = document.getElementById('settings-sound-toggle');
        if (!settingsSoundToggle) return; // Exit if settings sound toggle not found

        soundEnabled = settingsSoundToggle.checked;

        settingsSoundToggle.addEventListener('change', function() {
            soundEnabled = this.checked;
            saveSettings();
            playSound('click');
        });
    }

    // Initialize Dark Mode Toggle (Only Settings Modal)
    function initializeDarkMode() {
        const settingsDarkModeToggle = document.getElementById('settings-dark-mode-toggle');
        if (!settingsDarkModeToggle) return; // Exit if settings dark mode toggle not found

        if (localStorage.getItem('darkMode') === 'enabled') {
            document.body.classList.add('dark-mode');
            settingsDarkModeToggle.checked = true;
        }

        settingsDarkModeToggle.addEventListener('change', function() {
            if (this.checked) {
                document.body.classList.add('dark-mode');
                localStorage.setItem('darkMode', 'enabled');
            } else {
                document.body.classList.remove('dark-mode');
                localStorage.setItem('darkMode', 'disabled');
            }
            applySelectedTheme();
            playSound('click');
        });
    }

    // Load Player Names from Inputs
    function loadPlayerNames() {
        const playerXInput = document.getElementById('playerX-name');
        const playerOInput = document.getElementById('playerO-name');

        // Load saved names from localStorage
        const savedPlayerX = localStorage.getItem('playerXName');
        const savedPlayerO = localStorage.getItem('playerOName');
        if (savedPlayerX) {
            playerXInput.value = savedPlayerX;
            playerXName = savedPlayerX;
        }
        if (savedPlayerO) {
            playerOInput.value = savedPlayerO;
            playerOName = savedPlayerO;
        }

        playerXInput.addEventListener('input', function() {
            playerXName = this.value.trim() || 'Player X';
            updateScoreboard();
            savePlayerNames();
        });

        playerOInput.addEventListener('input', function() {
            playerOName = this.value.trim() || (mode === 'computer' ? 'Computer' : 'Player O');
            updateScoreboard();
            savePlayerNames();
        });
    }

    // Save Player Names to localStorage
    function savePlayerNames() {
        localStorage.setItem('playerXName', playerXName);
        localStorage.setItem('playerOName', playerOName);
    }

    // Load Scores from localStorage
    function loadScores() {
        const savedScores = JSON.parse(localStorage.getItem('tttScores'));
        if (savedScores) {
            scores = savedScores;
        }
        updateScoreboard();
    }

    // Save Scores to localStorage
    function saveScores() {
        localStorage.setItem('tttScores', JSON.stringify(scores));
    }

    // Load Settings from localStorage
    function loadSettings() {
        const savedSettings = JSON.parse(localStorage.getItem('tttSettings'));
        if (savedSettings) {
            soundEnabled = savedSettings.soundEnabled;
            aiDifficulty = savedSettings.aiDifficulty || 'medium';
            selectedTheme = savedSettings.selectedTheme || 'theme-default';

            // Apply sound setting
            const settingsSoundToggle = document.getElementById('settings-sound-toggle');
            if (settingsSoundToggle) {
                settingsSoundToggle.checked = soundEnabled;
            }

            // Apply AI difficulty
            const aiSelect = document.querySelector('#ai-difficulty-select .select-selected');
            if (aiSelect) {
                aiSelect.innerHTML = `Select AI Difficulty (${capitalizeFirstLetter(aiDifficulty)})`;
                aiSelect.setAttribute('data-value', aiDifficulty);
            }

            // Apply theme setting
            const themeSelect = document.querySelector('#theme-select .select-selected');
            if (themeSelect) {
                let themeName = selectedTheme.replace('theme-', '');
                themeName = capitalizeFirstLetter(themeName);
                themeSelect.innerHTML = `Select Theme (${themeName})`;
                themeSelect.setAttribute('data-value', selectedTheme);
            }
        }
    }

    // Save Settings to localStorage
    function saveSettings() {
        const settings = {
            soundEnabled: soundEnabled,
            aiDifficulty: aiDifficulty,
            selectedTheme: selectedTheme
        };
        localStorage.setItem('tttSettings', JSON.stringify(settings));
    }

    // Load Statistics from localStorage
    function loadStatistics() {
        const savedStatistics = JSON.parse(localStorage.getItem('tttStatistics'));
        if (savedStatistics) {
            statistics = savedStatistics;
        }
    }

    // Save Statistics to localStorage
    function saveStatistics() {
        localStorage.setItem('tttStatistics', JSON.stringify(statistics));
    }

    // Apply Selected Theme
    function applySelectedTheme() {
        const container = document.getElementById('game-container');
        // Remove all theme classes
        container.className = 'container';
        themes.forEach(theme => container.classList.remove(theme));
        // Add selected theme class
        container.classList.add(selectedTheme);
        // Add dark mode class if enabled
        if (document.body.classList.contains('dark-mode')) {
            container.classList.add('dark-mode');
        }
        document.body.style.background = getComputedStyle(container).getPropertyValue('--primary-gradient');
    }

    // Capitalize First Letter Utility Function
    function capitalizeFirstLetter(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
    }

    // Start Game Function
    function startGame(selectedMode) {
        mode = selectedMode;
        document.getElementById('initial-menu').classList.add('hidden-element');
        document.getElementById('game-interface').classList.remove('hidden-element');

        // Show or hide buttons based on mode
        if (mode === 'computer') {
            document.getElementById('hint-button').classList.remove('hidden-element');
            document.getElementById('undo-button').classList.remove('hidden-element');
            document.getElementById('ai-difficulty-select').style.display = 'block';

            // Enable buttons
            document.getElementById('hint-button').disabled = false;
            document.getElementById('undo-button').disabled = false;
        } else {
            // Show buttons but disable them
            document.getElementById('hint-button').classList.remove('hidden-element');
            document.getElementById('undo-button').classList.remove('hidden-element');
            document.getElementById('ai-difficulty-select').style.display = 'none';

            // Disable buttons
            document.getElementById('hint-button').disabled = true;
            document.getElementById('undo-button').disabled = true;
        }

        setupGame();
        showNotification('Game Started!');
        playSound('click');
    }

    // Setup Game Function
    function setupGame() {
        const gameBoard = document.getElementById('game-board');
        const selectedGridSize = document.querySelector('#board-size-select .select-selected').getAttribute('data-value');
        gridSize = parseInt(selectedGridSize) || 4;
        winCondition = getWinCondition(gridSize);
        currentPlayer = 'X';
        gameActive = true;
        board = Array(gridSize).fill(null).map(() => Array(gridSize).fill(null));
        moveHistory = [];
        hintUsed = false;
        undoUsed = false;
        playerOName = mode === 'computer' ? (playerOName || 'Computer') : (playerOName || 'Player O');
        updateStatus();
        updateScoreboard();
        document.getElementById('hint-button').disabled = mode !== 'computer'; // Disabled in 2-player
        document.getElementById('undo-button').disabled = mode !== 'computer'; // Disabled in 2-player

        // Reset buttons to enabled state in Computer mode
        if (mode === 'computer') {
            document.getElementById('hint-button').disabled = false;
            document.getElementById('undo-button').disabled = false;
            // Remove any previous hints or undos
        }

        // Hide Hint and Undo buttons in 2 Players mode
        if (mode === 'player') {
            // Buttons are shown but disabled
            document.getElementById('hint-button').disabled = true;
            document.getElementById('undo-button').disabled = true;
        }

        document.getElementById('game-container').className = 'container ' + selectedTheme + (document.body.classList.contains('dark-mode') ? ' dark-mode' : '');
        document.body.style.background = getComputedStyle(document.getElementById('game-container')).getPropertyValue('--primary-gradient');
        gameBoard.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;
        gameBoard.style.gridTemplateRows = `repeat(${gridSize}, 1fr)`;
        gameBoard.innerHTML = '';

        for (let i = 0; i < gridSize * gridSize; i++) {
            const cell = document.createElement('div');
            cell.addEventListener('click', handleCellClick);
            cell.dataset.index = i;
            gameBoard.appendChild(cell);
        }

        // Reset buttons visibility and state
        resetButtons();
    }

    // Reset Buttons Function
    function resetButtons() {
        // In Computer mode, buttons are shown and can be used once
        if (mode === 'computer') {
            const hintButton = document.getElementById('hint-button');
            const undoButton = document.getElementById('undo-button');

            hintButton.disabled = false;
            undoButton.disabled = false;
        } else {
            // In 2 Players mode, buttons are shown but disabled
            document.getElementById('hint-button').disabled = true;
            document.getElementById('undo-button').disabled = true;
        }
    }

    // Get Win Condition Based on Grid Size
    function getWinCondition(size) {
        if (size === 4 || size === 5) return 4;
        if (size === 6) return 5;
        if (size === 7) return 6;
        return 3; // default for other sizes
    }

    // Handle Cell Click
    function handleCellClick(event) {
        const cell = event.target;
        const index = parseInt(cell.dataset.index);
        const row = Math.floor(index / gridSize);
        const col = index % gridSize;

        if (board[row][col] !== null || !gameActive || (mode === 'computer' && currentPlayer === 'O')) {
            return;
        }

        makeMove(row, col, currentPlayer);

        if (checkWinner(row, col)) {
            updateStatus(`${getPlayerName(currentPlayer)} wins!`);
            gameActive = false;
            scores[currentPlayer]++;
            updateScoreboard();
            updateStatistics(currentPlayer === 'X' ? 'win' : 'loss');
            saveScores();
            playSound('win');
            triggerConfetti();
            highlightWin();
            handleGameEnd(`${getPlayerName(currentPlayer)} wins!`);
            return;
        }

        if (isDraw()) {
            updateStatus(`It's a draw!`);
            gameActive = false;
            updateStatistics('draw');
            saveScores();
            playSound('draw');
            handleGameEnd(`It's a draw!`);
            return;
        }

        currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
        updateStatus();

        if (mode === 'computer' && currentPlayer === 'O') {
            setTimeout(computerMove, 500); // Added delay for better UX
        }
    }

    // Make Move Function
    function makeMove(row, col, player, record = true) {
        board[row][col] = player;
        const index = row * gridSize + col;
        const gameBoard = document.getElementById('game-board');
        const cell = gameBoard.children[index];
        cell.textContent = player;

        // Remove any existing style classes for O
        if (player === 'O') {
            oStyles.forEach(style => cell.classList.remove(style));
        }

        // Add O style if player is O
        if (player === 'O') {
            const randomStyle = oStyles[Math.floor(Math.random() * oStyles.length)];
            cell.classList.add(randomStyle);
        }

        cell.classList.add(player);
        cell.classList.add('disabled');

        if (record) {
            moveHistory.push({ row, col, player });
        }

        playSound('move');
    }

    // Check Winner Function
    function checkWinner(row, col) {
        return (
            checkDirection(row, col, 0, 1) || // Horizontal
            checkDirection(row, col, 1, 0) || // Vertical
            checkDirection(row, col, 1, 1) || // Diagonal down-right
            checkDirection(row, col, 1, -1)   // Diagonal up-right
        );
    }

    // Check Direction Function
    function checkDirection(row, col, rowDir, colDir) {
        let count = 1;
        let winningCells = [[row, col]];

        // Check in the positive direction
        let r = row + rowDir;
        let c = col + colDir;
        while (r >= 0 && r < gridSize && c >= 0 && c < gridSize && board[r][c] === currentPlayer) {
            count++;
            winningCells.push([r, c]);
            r += rowDir;
            c += colDir;
        }

        // Check in the negative direction
        r = row - rowDir;
        c = col - colDir;
        while (r >= 0 && r < gridSize && c >= 0 && c < gridSize && board[r][c] === currentPlayer) {
            count++;
            winningCells.push([r, c]);
            r -= rowDir;
            c -= colDir;
        }

        if (count >= winCondition) {
            highlightCells(winningCells);
            return true;
        }
        return false;
    }

    // Highlight Winning Cells
    function highlightCells(cells) {
        const gameBoard = document.getElementById('game-board');
        cells.forEach(([row, col]) => {
            const index = row * gridSize + col;
            const cell = gameBoard.children[index];
            cell.classList.add('highlight');
            cell.classList.add('win-animation');
        });
    }

    // Highlight Win Function
    function highlightWin() {
        const status = document.getElementById('status');
        status.classList.add('win-animation');
        setTimeout(() => {
            status.classList.remove('win-animation');
        }, 1000);
    }

    // Check Draw Function
    function isDraw() {
        for (let row of board) {
            if (row.includes(null)) {
                return false;
            }
        }
        return true;
    }

    // Update Status Function
    function updateStatus(message) {
        const status = document.getElementById('status');
        if (message) {
            status.textContent = message;
        } else {
            status.textContent = `${getPlayerName(currentPlayer)}'s turn`;
        }
    }

    // Update Scoreboard Function
    function updateScoreboard() {
        const playerXScore = document.getElementById('playerX-score');
        const playerOScore = document.getElementById('playerO-score');
        playerXScore.textContent = `${getPlayerName('X')}: ${scores['X']}`;
        playerOScore.textContent = `${getPlayerName('O')}: ${scores['O']}`;
    }

    // Get Player Name Function
    function getPlayerName(player) {
        if (mode === 'player') {
            const name = player === 'X' ? document.getElementById('playerX-name').value.trim() : document.getElementById('playerO-name').value.trim();
            return name || `Player ${player}`;
        } else {
            return player === 'X' ? (document.getElementById('playerX-name').value.trim() || 'You') : (document.getElementById('playerO-name').value.trim() || 'Computer');
        }
    }

    // Undo Move Function
    function undoMove() {
        if (undoUsed || moveHistory.length === 0 || !gameActive) {
            showNotification('Cannot undo move.');
            return;
        }

        if (mode === 'computer') {
            // Undo both player's and computer's last moves
            undoLastMove(); // Undo computer's move
            undoLastMove(); // Undo player's move
        } else {
            // Undo last move in 2-player mode
            undoLastMove();
        }

        undoUsed = true;
        if (mode === 'computer') {
            document.getElementById('undo-button').disabled = true; // Disable after use
        }
        updateStatus();
        playSound('click');
    }

    // Undo Last Move Helper Function
    function undoLastMove() {
        if (moveHistory.length === 0) {
            return;
        }

        const lastMove = moveHistory.pop();
        const { row, col, player } = lastMove;
        board[row][col] = null;
        const index = row * gridSize + col;
        const gameBoard = document.getElementById('game-board');
        const cell = gameBoard.children[index];
        cell.textContent = '';
        cell.classList.remove('X', 'O', 'disabled', 'highlight', 'win-animation');
        // Remove O style classes
        oStyles.forEach(style => cell.classList.remove(style));
    }

    // Show Hint Function
    function showHint() {
        if (hintUsed || !gameActive || mode !== 'computer' || currentPlayer !== 'X') {
            return;
        }

        const bestMove = getBestMove();
        if (!bestMove) return; // No moves available

        const index = bestMove.row * gridSize + bestMove.col;
        const gameBoard = document.getElementById('game-board');
        const cell = gameBoard.children[index];

        cell.style.boxShadow = '0 0 10px 5px yellow';
        setTimeout(() => {
            cell.style.boxShadow = '';
        }, 2000);

        hintUsed = true;
        document.getElementById('hint-button').disabled = true; // Disable after use
        updateStatus(`${getPlayerName('X')} received a hint!`);
        playSound('click');
    }

    // Computer Move Function
    function computerMove() {
        if (!gameActive) return;

        let move;

        switch (aiDifficulty) {
            case 'easy':
                move = getRandomMove();
                break;
            case 'medium':
                move = Math.random() < 0.5 ? getBestMove() : getRandomMove();
                break;
            case 'hard':
                move = getBestMove();
                break;
            default:
                move = getBestMove();
        }

        if (move) {
            makeMove(move.row, move.col, 'O');

            if (checkWinner(move.row, move.col)) {
                updateStatus(`Computer wins!`);
                gameActive = false;
                scores['O']++;
                updateScoreboard();
                updateStatistics('loss');
                saveScores();
                playSound('win');
                triggerConfetti();
                highlightWin();
                handleGameEnd(`Computer wins!`);
                return;
            }

            if (isDraw()) {
                updateStatus(`It's a draw!`);
                gameActive = false;
                updateStatistics('draw');
                saveScores();
                playSound('draw');
                handleGameEnd(`It's a draw!`);
                return;
            }

            currentPlayer = 'X';
            updateStatus();
        }
    }

    // Get Best Move Function (Minimax Algorithm)
    function getBestMove() {
        let bestScore = -Infinity;
        let move;

        for (let row = 0; row < gridSize; row++) {
            for (let col = 0; col < gridSize; col++) {
                if (board[row][col] === null) {
                    board[row][col] = 'O';
                    let score = minimax(board, 0, false, -Infinity, Infinity);
                    board[row][col] = null;
                    if (score > bestScore) {
                        bestScore = score;
                        move = { row, col };
                    }
                }
            }
        }

        return move;
    }

    // Minimax Algorithm with Alpha-Beta Pruning
    function minimax(boardState, depth, isMaximizing, alpha, beta) {
        if (checkWinMinimax('O', boardState)) return 10 - depth;
        if (checkWinMinimax('X', boardState)) return depth - 10;
        if (isBoardFull(boardState)) return 0;

        // Limit depth to improve performance on larger grids
        let MAX_DEPTH;
        if (gridSize >= 5) {
            switch (aiDifficulty) {
                case 'easy':
                    MAX_DEPTH = 1;
                    break;
                case 'medium':
                    MAX_DEPTH = 2;
                    break;
                case 'hard':
                    MAX_DEPTH = 3;
                    break;
                default:
                    MAX_DEPTH = 2;
            }
        } else {
            switch (aiDifficulty) {
                case 'easy':
                    MAX_DEPTH = 1;
                    break;
                case 'medium':
                    MAX_DEPTH = 3;
                    break;
                case 'hard':
                    MAX_DEPTH = 5;
                    break;
                default:
                    MAX_DEPTH = 3;
            }
        }

        if (depth >= MAX_DEPTH) {
            return 0;
        }

        if (isMaximizing) {
            let maxEval = -Infinity;
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    if (boardState[row][col] === null) {
                        boardState[row][col] = 'O';
                        let eval = minimax(boardState, depth + 1, false, alpha, beta);
                        boardState[row][col] = null;
                        maxEval = Math.max(maxEval, eval);
                        alpha = Math.max(alpha, eval);
                        if (beta <= alpha) break;
                    }
                }
            }
            return maxEval;
        } else {
            let minEval = Infinity;
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    if (boardState[row][col] === null) {
                        boardState[row][col] = 'X';
                        let eval = minimax(boardState, depth + 1, true, alpha, beta);
                        boardState[row][col] = null;
                        minEval = Math.min(minEval, eval);
                        beta = Math.min(beta, eval);
                        if (beta <= alpha) break;
                    }
                }
            }
            return minEval;
        }
    }

    // Check Win for Minimax
    function checkWinMinimax(player, boardState) {
        // Check rows, columns, and diagonals
        for (let row = 0; row < gridSize; row++) {
            for (let col = 0; col < gridSize; col++) {
                if (
                    (col <= gridSize - winCondition && checkLineMinimax(player, boardState, row, col, 0, 1)) || // Horizontal
                    (row <= gridSize - winCondition && checkLineMinimax(player, boardState, row, col, 1, 0)) || // Vertical
                    (row <= gridSize - winCondition && col <= gridSize - winCondition && checkLineMinimax(player, boardState, row, col, 1, 1)) || // Diagonal down-right
                    (row <= gridSize - winCondition && col >= winCondition - 1 && checkLineMinimax(player, boardState, row, col, 1, -1)) // Diagonal up-right
                ) {
                    return true;
                }
            }
        }
        return false;
    }

    // Check Line for Minimax
    function checkLineMinimax(player, boardState, row, col, rowDir, colDir) {
        for (let i = 0; i < winCondition; i++) {
            if (boardState[row + i * rowDir] === undefined || boardState[row + i * rowDir][col + i * colDir] !== player) {
                return false;
            }
        }
        return true;
    }

    // Check if Board is Full
    function isBoardFull(boardState) {
        for (let row of boardState) {
            if (row.includes(null)) {
                return false;
            }
        }
        return true;
    }

    // Get Random Move Function
    function getRandomMove() {
        let availableMoves = [];
        for (let row = 0; row < gridSize; row++) {
            for (let col = 0; col < gridSize; col++) {
                if (board[row][col] === null) {
                    availableMoves.push({ row, col });
                }
            }
        }
        return availableMoves[Math.floor(Math.random() * availableMoves.length)];
    }

    // Play Sound Function
    function playSound(type) {
        if (!soundEnabled) return;
        const soundMap = {
            'move': 'move-sound',
            'win': 'win-sound',
            'draw': 'draw-sound',
            'click': 'click-sound'
        };
        const sound = document.getElementById(soundMap[type]);
        if (sound) {
            sound.currentTime = 0;
            sound.play();
        }
    }

    // Trigger Confetti Function
    function triggerConfetti() {
        confetti({
            particleCount: 150,
            spread: 70,
            origin: { y: 0.6 }
        });
    }

    // Exit Game Function
    function exitGame() {
        // Replace alert with custom confirm modal
        confirmModal('Do you want to leave the game?')
            .then(result => {
                if (result) {
                    // Reset scores
                    resetScores();

                    // Clear saved game data
                    localStorage.removeItem('tttSavedGame');

                    // Reset statistics if needed
                    // If you want to keep statistics across sessions, comment out the next line
                    // resetStatistics();

                    // Reset the scoreboard
                    resetScoreboard();

                    // Reset scores object
                    scores = { 'X': 0, 'O': 0 };
                    saveScores();

                    // Reset game state
                    gameActive = false;

                    // Reset move history
                    moveHistory = [];

                    // Reset hint and undo usage
                    hintUsed = false;
                    undoUsed = false;

                    // Hide game interface and show initial menu
                    document.getElementById('game-interface').classList.add('hidden-element');
                    document.getElementById('initial-menu').classList.remove('hidden-element');

                    showNotification('Exited the game and scores have been reset.');
                    playSound('click');
                }
                // If no, do nothing and stay in the game
            });
    }

    // Function to reset scores (if stored in localStorage or other storage)
    function resetScores() {
        scores = { 'X': 0, 'O': 0 };
        saveScores();
    }

    // Function to reset statistics (optional)
    function resetStatistics() {
        statistics = { totalGames: 0, totalWins: 0, totalLosses: 0, totalDraws: 0 };
        saveStatistics();
    }

    // Reset Scoreboard Display
    function resetScoreboard() {
        const playerXScore = document.getElementById('playerX-score');
        const playerOScore = document.getElementById('playerO-score');
        playerXScore.textContent = `${getPlayerName('X')}: 0`;
        playerOScore.textContent = `${getPlayerName('O')}: 0`;
    }

    // Settings Modal Functions
    function openSettings() {
        document.getElementById('settings-modal').style.display = 'flex';
        playSound('click');
    }

    function closeSettings(event) {
        event.stopPropagation(); // Prevent event bubbling
        document.getElementById('settings-modal').style.display = 'none';
        playSound('click');
    }

    // Notification Modal Functions
    function showNotification(message) {
        return new Promise((resolve) => {
            const notificationModal = document.getElementById('notification-modal');
            const notificationMessage = document.getElementById('notification-message');
            notificationMessage.textContent = message;
            notificationModal.style.display = 'flex'; // Ensure it's displayed as flex for centering

            // Close the notification after a timeout
            setTimeout(() => {
                closeNotification();
                resolve();
            }, 3000); // 3 seconds
        });
    }

    function closeNotification(event) {
        if (event) event.stopPropagation(); // Prevent event bubbling
        const notificationModal = document.getElementById('notification-modal');
        notificationModal.style.display = 'none';
    }

    // Replace confirm with custom modal
    function confirmModal(message) {
        return new Promise((resolve) => {
            // Create a custom confirm modal
            const confirmModal = document.createElement('div');
            confirmModal.classList.add('modal');
            confirmModal.innerHTML = `
                <div class="modal-content">
                    <p>${message}</p>
                    <button class="button" id="confirm-yes">Yes</button>
                    <button class="button" id="confirm-no">No</button>
                </div>
            `;
            document.body.appendChild(confirmModal);

            // Style the confirm buttons
            const confirmYes = confirmModal.querySelector('#confirm-yes');
            const confirmNo = confirmModal.querySelector('#confirm-no');

            confirmYes.addEventListener('click', () => {
                resolve(true);
                confirmModal.remove();
            });

            confirmNo.addEventListener('click', () => {
                resolve(false);
                confirmModal.remove();
            });

            // Close modal if clicked outside
            confirmModal.addEventListener('click', (event) => {
                if (event.target === confirmModal) {
                    resolve(false);
                    confirmModal.remove();
                }
            });
        });
    }

    // Statistics Functions
    function updateStatistics(result) {
        statistics.totalGames++;
        if (result === 'win') {
            statistics.totalWins++;
        } else if (result === 'loss') {
            statistics.totalLosses++;
        } else if (result === 'draw') {
            statistics.totalDraws++;
        }
        saveStatistics();
        // Optionally, update a statistics display in the UI
    }

    // Handle Game End to Remove Timer (Previously handled by timer functions)
    function handleGameEnd(result) {
        // Since timer is removed, no need to clearInterval or handle timeout
        showNotification(result).then(() => {
            setupGame();
        });
    }

    // Function to adjust cell sizes based on window size (optional)
    function adjustCellSizes() {
        // Implement any responsive adjustments if needed
        // Currently, cells are responsive via CSS
    }


                    </script>
                </body>
</html>
